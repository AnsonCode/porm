package cmd

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/AnsonCode/porm/config"
	"github.com/AnsonCode/porm/engine"
	"github.com/AnsonCode/porm/engine/introspection"
	"github.com/AnsonCode/porm/engine/utils"

	"github.com/prisma/prisma-client-go/binaries"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"

	yaml "gopkg.in/yaml.v3"
)

var provider, url string

// Do runs the command logic.
func Do(args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer) int {
	rootCmd := &cobra.Command{Use: "porm", SilenceUsage: true}
	rootCmd.PersistentFlags().StringP("file", "f", "", "specify an alternate config file (default: porm.yaml)")
	rootCmd.PersistentFlags().BoolP("experimental", "x", false, "enable experimental features (default: false)")

	rootCmd.AddCommand(checkCmd)
	rootCmd.AddCommand(genCmd)
	rootCmd.AddCommand(initCmd)
	rootCmd.AddCommand(installCmd)
	rootCmd.AddCommand(sdlCmd)
	rootCmd.AddCommand(pullCmd)
	pullCmd.Flags().StringVarP(&provider, "provider", "p", "mysql", "数据库类型")
	pullCmd.Flags().StringVarP(&url, "url", "u", "", "数据库连接:mysql://xxx:xxxx@ip:port/databasename")

	// rootCmd.AddCommand(playgroundCmd)

	rootCmd.AddCommand(versionCmd)
	// rootCmd.AddCommand(uploadCmd)

	rootCmd.SetArgs(args)
	rootCmd.SetIn(stdin)
	rootCmd.SetOut(stdout)
	rootCmd.SetErr(stderr)

	// ctx, cleanup, err := tracer.Start(context.Background())
	// if err != nil {
	// 	fmt.Printf("failed to start trace: %v\n", err)
	// 	return 1
	// }
	// defer cleanup()
	ctx := context.Background()
	if err := rootCmd.ExecuteContext(ctx); err == nil {
		return 0
	}
	// if exitError, ok := err.(*exec.ExitError); ok {
	// 	return exitError.ExitCode()
	// }
	return 1
}

var version string

const Version = "v0.15.0"

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the porm version number",
	Run: func(cmd *cobra.Command, args []string) {
		if version == "" {
			fmt.Printf("%s\n", Version)
		} else {
			fmt.Printf("%s\n", version)
		}
	},
}

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Create an empty porm.yaml settings file",
	RunE: func(cmd *cobra.Command, args []string) error {
		file := "porm.yaml"
		if f := cmd.Flag("file"); f != nil && f.Changed {
			file = f.Value.String()
			if file == "" {
				return fmt.Errorf("file argument is empty")
			}
		}
		if _, err := os.Stat(file); !os.IsNotExist(err) {
			fmt.Printf("file (%s) is exist", file)
			return nil

		}
		defaultConf := config.Config{
			Version: "1.0",
			Prisma: &config.PrismaConf{
				SchemaPath:          "schema.prisma",
				GraphqlPath:         "schema.graphql",
				BaseDir:             "./prisma",
				QueryEnginePort:     8123,
				PlaygroundPort:      8124,
				QueryEngine:         true,
				MigrationEngine:     true,
				IntrospectionEngine: true,
			},
			SQL: []config.SQL{
				{
					Schema:  []string{"todo"},
					Queries: []string{"todo"},
					Gen: config.SQLGen{
						Go: &config.SQLGo{
							Package: "demo",
							Out:     "demo",
						},
					},
				},
			},
		}

		blob, err := yaml.Marshal(defaultConf)
		if err != nil {
			return err
		}
		return os.WriteFile(file, blob, 0644)
	},
}

type Env struct {
	ExperimentalFeatures bool
	DryRun               bool
}

func ParseEnv(c *cobra.Command) Env {
	x := c.Flag("experimental")
	dr := c.Flag("dry-run")
	return Env{
		ExperimentalFeatures: x != nil && x.Changed,
		DryRun:               dr != nil && dr.Changed,
	}
}

func getConfigPath(stderr io.Writer, f *pflag.Flag) (string, string) {
	if f != nil && f.Changed {
		file := f.Value.String()
		if file == "" {
			fmt.Fprintln(stderr, "error parsing config: file argument is empty")
			os.Exit(1)
		}
		abspath, err := filepath.Abs(file)
		if err != nil {
			fmt.Fprintf(stderr, "error parsing config: absolute file path lookup failed: %s\n", err)
			os.Exit(1)
		}
		return filepath.Dir(abspath), filepath.Base(abspath)
	} else {
		wd, err := os.Getwd()
		if err != nil {
			fmt.Fprintln(stderr, "error parsing porm.json: file does not exist")
			os.Exit(1)
		}
		return wd, ""
	}
}

var genCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate Go code from GraphQL",
	Run: func(cmd *cobra.Command, args []string) {

		stderr := cmd.ErrOrStderr()
		dir, name := getConfigPath(stderr, cmd.Flag("file"))
		output, err := Generate(cmd.Context(), ParseEnv(cmd), dir, name, stderr)
		if err != nil {
			os.Exit(1)
		}
		// TODO:生成前先删除一拨
		for filename, source := range output {
			os.MkdirAll(filepath.Dir(filename), 0755)
			if err := os.WriteFile(filename, []byte(source), 0644); err != nil {
				fmt.Fprintf(stderr, "%s: %s\n", filename, err)
				os.Exit(1)
			}
		}
		// TODO:写入gitignore 文件
	},
}

// func gitignore() {
// 	var gitignore = "# gitignore generated by Prisma Client Go. DO NOT EDIT.\n*.go\n"
// 	if err := os.MkdirAll(input.Generator.Output.Value, os.ModePerm); err != nil {
// 		return fmt.Errorf("could not create output directory: %w", err)
// 	}
// 	if err := os.WriteFile(path.Join(input.Generator.Output.Value, ".gitignore"), []byte(gitignore), 0644); err != nil {
// 		return fmt.Errorf("could not write .gitignore: %w", err)
// 	}
// }

var checkCmd = &cobra.Command{
	Use:   "compile",
	Short: "Statically check GraphQL for syntax and type errors",
	RunE: func(cmd *cobra.Command, args []string) error {

		stderr := cmd.ErrOrStderr()
		dir, name := getConfigPath(stderr, cmd.Flag("file"))
		if _, err := Generate(cmd.Context(), ParseEnv(cmd), dir, name, stderr); err != nil {
			os.Exit(1)
		}
		return nil
	},
}

func initConf(cmd *cobra.Command) *config.Config {
	stderr := cmd.ErrOrStderr()
	dir, name := getConfigPath(stderr, cmd.Flag("file"))
	configPath, conf, err := readConfig(stderr, dir, name)
	if err != nil {
		panic(err)
	}

	base := filepath.Base(configPath)
	if err := config.Validate(conf); err != nil {
		fmt.Fprintf(stderr, "error validating %s: %s\n", base, err)
		panic(err)
	}
	return conf
}

var installCmd = &cobra.Command{
	Use:   "install",
	Short: "Install prisma  engine based config",
	Run: func(cmd *cobra.Command, args []string) {
		// TODO：
		conf := initConf(cmd)
		toDir := conf.Prisma.BaseDir
		if conf.Prisma.QueryEngine {
			file, err := binaries.DownloadEngine("query-engine", toDir)
			if err != nil {
				fmt.Println("could not download engines: %w", err)
				return
			}
			fmt.Println("下载完毕：", file)
		}
		if conf.Prisma.MigrationEngine {
			file, err := binaries.DownloadEngine("migration-engine", toDir)
			if err != nil {
				fmt.Println("could not download engines: %w", err)
				return
			}
			fmt.Println("下载完毕：", file)
		}
		if conf.Prisma.IntrospectionEngine {
			file, err := binaries.DownloadEngine("introspection-engine", toDir)
			if err != nil {
				fmt.Println("could not download engines: %w", err)
				return
			}
			fmt.Println("下载完毕：", file)
		}
	},
}

var sdlCmd = &cobra.Command{
	Use:   "sdl",
	Short: "get graphql.schema form prisma",
	Run: func(cmd *cobra.Command, args []string) {
		conf := initConf(cmd)
		prismaConf := conf.Prisma
		content, err := os.ReadFile(prismaConf.SchemaPath)
		if err != nil {
			panic(err)
		}

		enginePath := utils.GetQueryEnginePath(prismaConf.BaseDir) // 构建引擎路径
		//这个后续要换成随机的，避免冲突
		port := prismaConf.QueryEnginePort
		client := engine.NewQueryEngine(string(content), port, 0, enginePath)
		if err := client.Connect(); err != nil {
			fmt.Println("------------------------------->")
			fmt.Println(err)
			panic(err)
		}
		defer client.Disconnect()

		// TODO：sdl
		ctx := context.TODO()
		// 内省获取 graphql schema
		sdl, err := client.IntrospectSDL(ctx)
		if err != nil {
			panic(err)
		}
		if err := os.WriteFile(prismaConf.GraphqlPath, sdl, 0666); err != nil {
			panic(err)
		}
		fmt.Println("\n获取成功~")
	},
}

var pullCmd = &cobra.Command{
	Use:   "pull",
	Short: "内省数据库获取schema.prisma",
	Run: func(cmd *cobra.Command, args []string) {
		// TODO：
		conf := initConf(cmd)
		prismaConf := conf.Prisma
		enginePath := utils.GetIntrospectionEnginePath(prismaConf.BaseDir) // 构建引擎路径

		engine := introspection.NewIntrospectEngine(enginePath)
		schema, err := engine.Pull(provider, url)
		// fmt.Println(schema, err)
		if err != nil {
			panic(err)
		}
		if err := os.WriteFile(prismaConf.SchemaPath, []byte(schema), 0666); err != nil {
			panic(err)
		}
		fmt.Println("\n获取成功~")
	},
}
